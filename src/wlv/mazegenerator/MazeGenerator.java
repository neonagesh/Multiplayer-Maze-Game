package wlv.mazegenerator;

/** This class will help you generate a new maze. 
 * 
 * Each time you call one of the generateMaze() methods a different maze will 
 * be generated. You can save the maze.jpg file that is generated by the
 * class, or save the CellGrid object that is generated, or both. Either way,
 * you MUST use DB4O.    
 * 
 *  @author Sarah Mount, Gordon Branson.
 *  @date February 2012.
 */

import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Stack;

import javax.imageio.ImageIO;

import com.graphics.AWTGraphicsContext;

public class MazeGenerator {

	private static final int DEFAULT_HEIGHT = 800;
	private static final int DEFAULT_WIDTH = 800;
	private CellGrid grid;
	private int row, col;
	private int curRow, curCol, curNum;
	private CellReference currentCell, start, exit;
	private char dir;
	private Stack<CellReference> stack;
	private boolean loopEnabled;

	public MazeGenerator() {
		row = 10;
		col = 10;
		curNum = 1;
		loopEnabled = false;
		generateMaze();
		currentCell = grid.getCurrentCell();
	}

	private int getRand(int max) {
		return (int) (Math.random() * max);
	}

	private char reverse(char d) {
		switch (d) {
		case 'N':
		case 'n':
			return 'S';
		case 'S':
		case 's':
			return 'N';
		case 'W':
		case 'w':
			return 'E';
		case 'E':
		case 'e':
			return 'W';
		}
		return d;
	}

	private ArrayList<CellReference> countUnvisited(CellReference cellReference) {
		int x 			= cellReference.getX();
		int y 			= cellReference.getY();
		char direction 	= cellReference.getDirection();
		
		ArrayList<CellReference> possibles = new ArrayList<CellReference>();
		
		switch (direction) {
			case 'N':
			case 'n':
				if (x < (row - 1) && grid.getCellNumber(x + 1, y) == 0) {
					possibles.add(new CellReference(x + 1, y, 'N'));
				}
				
				if (y > 0) {
					if (grid.getCellNumber(x, y - 1) == 0) {
						possibles.add(new CellReference(x, y - 1, 'W'));
					}
				
					if (y < (col - 1) && grid.getCellNumber(x, y + 1) == 0) {
							possibles.add(new CellReference(x, y + 1, 'E'));
					}
				}
					
				break;
			case 'S':
			case 's':
				
				if (x > 0 && grid.getCellNumber(x - 1, y) == 0) {
					possibles.add(new CellReference(x - 1, y, 'S'));
				}
					
				if (y > 0 && grid.getCellNumber(x, y - 1) == 0) {
					possibles.add(new CellReference(x, y - 1, 'W'));
				}
				
				if (y > 0 && y < (col - 1) && grid.getCellNumber(x, y + 1) == 0){
					possibles.add(new CellReference(x, y + 1, 'E'));
				}

				break;
			case 'W':
			case 'w':
				
				if (y > 0 && grid.getCellNumber(x, y - 1) == 0){ 
					possibles.add(new CellReference(x, y - 1, 'W'));
				}
						
				if (x > 0 && grid.getCellNumber(x - 1, y) == 0) {
					possibles.add(new CellReference(x - 1, y, 'S'));
				}
				
				if (x < (row - 1) && grid.getCellNumber(x + 1, y) == 0){ 
					possibles.add(new CellReference(x + 1, y, 'N'));
				}
				
				break;
			case 'E':
			case 'e':
				
				if (y < (col - 1) && grid.getCellNumber(x, y + 1) == 0) {
						possibles.add(new CellReference(x, y + 1, 'E'));
				}
				
				if (x > 0 && grid.getCellNumber(x - 1, y) == 0) {
					possibles.add(new CellReference(x - 1, y, 'S'));
				}
				
				if (x < (row - 1) && grid.getCellNumber(x + 1, y) == 0) {
					possibles.add(new CellReference(x + 1, y, 'N'));
				}
				
				break;
		}
		
		return possibles;
	}

	private ArrayList<CellReference> countVisited(CellReference cref) {
		int r = cref.getX();
		int c = cref.getY();
		char d = cref.getDirection();
		ArrayList<CellReference> possibles = new ArrayList<CellReference>();
		switch (d) {
		case 'N':
		case 'n':
			if (r < (row - 1))
				if (grid.getCellNumber(r + 1, c) > 0)
					possibles.add(new CellReference(r + 1, c, 'N'));
			break;
		case 'S':
		case 's':
			if (r > 0)
				if (grid.getCellNumber(r - 1, c) > 0)
					possibles.add(new CellReference(r - 1, c, 'S'));
			break;
		case 'W':
		case 'w':
			if (c > 0)
				if (grid.getCellNumber(r, c - 1) > 0)
					possibles.add(new CellReference(r, c - 1, 'W'));
			break;
		case 'E':
		case 'e':
			if (c < (col - 1))
				if (grid.getCellNumber(r, c + 1) > 0)
					possibles.add(new CellReference(r, c + 1, 'E'));
			break;
		}
		return possibles;
	}

	private void checkCell(CellReference cref) {
		int curRow = cref.getX();
		int curCol = cref.getY();
		if (grid.getCellNumber(curRow, curCol) == 0)
			grid.setCellNumber(curRow, curCol, curNum++);
		ArrayList<CellReference> possibles = countUnvisited(cref);
		int numCells = possibles.size();
		if (numCells == 0) {
			if (loopEnabled) {
				if (getRand(50) > 0)
					return;
				// make a break into another allready visited cell
				ArrayList<CellReference> poss = countVisited(cref);
				int numLoop = poss.size();
				System.out.println("numLoop = " + numLoop);
				if (numLoop < 1)
					return;
				int loopDestNum = getRand(numLoop + 1);
				CellReference loopDest = poss.get(loopDestNum % numLoop);
				grid.clearCellWall(cref.getX(), cref.getY(),
						loopDest.getDirection());
				grid.clearCellWall(loopDest.getX(), loopDest.getY(),
						reverse(loopDest.getDirection()));
			}
			return;
		}
		int destNum = getRand(numCells);// try numCells + 1
		if (numCells > 1)
			stack.push(cref);
		CellReference dest = possibles.get(destNum);// try destNum % numCells
		grid.clearCellWall(cref.getX(), cref.getY(), dest.getDirection());
		grid.clearCellWall(dest.getX(), dest.getY(), reverse(dest.getDirection()));
		checkCell(dest);
	}

	private void generateMaze() {
		stack = new Stack<CellReference>();
		grid = new CellGrid(row, col, loopEnabled);
		// set initial direction as North
		dir = 'N';
		// set start cell in row 0
		curRow = 0;
		curCol = getRand(col);
		start = new CellReference(0, curCol, 'N');
		curNum = 1;
		CellReference entry = new CellReference(curRow, curCol, dir);
		grid.setStart(new CellReference(0, curCol, 'S'));
		stack.push(entry);
		while (!stack.isEmpty()) {
			CellReference next = stack.pop();
			checkCell(next);
		}
		// make exit in last row
		curRow = row - 1;
		curCol = getRand(col);
		exit = new CellReference(curRow, curCol, 'N');
		grid.clearCellWall(curRow, curCol, 'N');
		grid.setExit(exit);
		grid.setCurrentCell(start);
	}

	private BufferedImage generateImage() {
		Dimension size = grid.getSize();
		BufferedImage image = new BufferedImage(size.width, size.height,
				BufferedImage.TYPE_INT_RGB);
		Graphics g = image.getGraphics();
		
		AWTGraphicsContext graphics = new AWTGraphicsContext(g);
		
		grid.draw2D(graphics);
		return image;
	}

	private void writeJpeg(String filename) {
		BufferedImage image = this.generateImage();
		try {
			ImageIO.write(image, "jpg", new File(filename));
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	public CellGrid generateMaze(int width, int height) {
		grid = new CellGrid(width, height, true);
		generateMaze();
		return grid;
	}

	public CellGrid generateMaze(String filename, int width, int height) {
		grid = new CellGrid(width, height, true);
		generateMaze();
		writeJpeg(filename);
		return grid;
	}

	public CellGrid generateMaze(String filename) {
		grid = new CellGrid(DEFAULT_WIDTH, DEFAULT_HEIGHT, true);
		generateMaze();
		writeJpeg(filename);
		return grid;
	}
}
