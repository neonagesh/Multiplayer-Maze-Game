package wlv.mazegenerator;

/** This class will help you generate a new maze. 
 * 
 * Each time you call one of the generateMaze() methods a different maze will 
 * be generated. You can save the maze.jpg file that is generated by the
 * class, or save the CellGrid object that is generated, or both. Either way,
 * you MUST use DB4O.    
 * 
 *  @author Sarah Mount, Gordon Branson.
 *  @date February 2012.
 */

import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Stack;

import javax.imageio.ImageIO;

import com.graphics.AWTGraphicsContext;

public class MazeGenerator {

	private static final int DEFAULT_HEIGHT = 800;
	private static final int DEFAULT_WIDTH = 800;
	private CellGrid grid;
	private int row, col;
	private int curRow, curCol, curNum;
	private CellRef currentCell, start, exit;
	private char dir;
	private Stack<CellRef> stack;
	private boolean loopEnabled;

	public MazeGenerator() {
		row = 10;
		col = 10;
		curNum = 1;
		loopEnabled = false;
		generateMaze();
		currentCell = grid.getCurrentCell();
	}

	private int getRand(int max) {
		return (int) (Math.random() * max);
	}

	private char reverse(char d) {
		switch (d) {
		case 'N':
		case 'n':
			return 'S';
		case 'S':
		case 's':
			return 'N';
		case 'W':
		case 'w':
			return 'E';
		case 'E':
		case 'e':
			return 'W';
		}
		return d;
	}

	private ArrayList<CellRef> countUnvisited(CellRef cref) {
		int r = cref.getRow();
		int c = cref.getCol();
		char d = cref.getDir();
		ArrayList<CellRef> possibles = new ArrayList<CellRef>();
		switch (d) {
		case 'N':
		case 'n':
			if (r < (row - 1))
				if (grid.getCellNumber(r + 1, c) == 0)
					possibles.add(new CellRef(r + 1, c, 'N'));
			if (c > 0)
				if (grid.getCellNumber(r, c - 1) == 0)
					possibles.add(new CellRef(r, c - 1, 'W'));
			if (c < (col - 1))
				if (grid.getCellNumber(r, c + 1) == 0)
					possibles.add(new CellRef(r, c + 1, 'E'));
			break;
		case 'S':
		case 's':
			if (r > 0)
				if (grid.getCellNumber(r - 1, c) == 0)
					possibles.add(new CellRef(r - 1, c, 'S'));
			if (c > 0)
				if (grid.getCellNumber(r, c - 1) == 0)
					possibles.add(new CellRef(r, c - 1, 'W'));
			if (c < (col - 1))
				if (grid.getCellNumber(r, c + 1) == 0)
					possibles.add(new CellRef(r, c + 1, 'E'));
			break;
		case 'W':
		case 'w':
			if (c > 0)
				if (grid.getCellNumber(r, c - 1) == 0)
					possibles.add(new CellRef(r, c - 1, 'W'));
			if (r > 0)
				if (grid.getCellNumber(r - 1, c) == 0)
					possibles.add(new CellRef(r - 1, c, 'S'));
			if (r < (row - 1))
				if (grid.getCellNumber(r + 1, c) == 0)
					possibles.add(new CellRef(r + 1, c, 'N'));
			break;
		case 'E':
		case 'e':
			if (c < (col - 1))
				if (grid.getCellNumber(r, c + 1) == 0)
					possibles.add(new CellRef(r, c + 1, 'E'));
			if (r > 0)
				if (r > 0)
					if (grid.getCellNumber(r - 1, c) == 0)
						possibles.add(new CellRef(r - 1, c, 'S'));
			if (r < (row - 1))
				if (grid.getCellNumber(r + 1, c) == 0)
					possibles.add(new CellRef(r + 1, c, 'N'));
			break;
		}
		return possibles;
	}

	private ArrayList<CellRef> countVisited(CellRef cref) {
		int r = cref.getRow();
		int c = cref.getCol();
		char d = cref.getDir();
		ArrayList<CellRef> possibles = new ArrayList<CellRef>();
		switch (d) {
		case 'N':
		case 'n':
			if (r < (row - 1))
				if (grid.getCellNumber(r + 1, c) > 0)
					possibles.add(new CellRef(r + 1, c, 'N'));
			break;
		case 'S':
		case 's':
			if (r > 0)
				if (grid.getCellNumber(r - 1, c) > 0)
					possibles.add(new CellRef(r - 1, c, 'S'));
			break;
		case 'W':
		case 'w':
			if (c > 0)
				if (grid.getCellNumber(r, c - 1) > 0)
					possibles.add(new CellRef(r, c - 1, 'W'));
			break;
		case 'E':
		case 'e':
			if (c < (col - 1))
				if (grid.getCellNumber(r, c + 1) > 0)
					possibles.add(new CellRef(r, c + 1, 'E'));
			break;
		}
		return possibles;
	}

	private void checkCell(CellRef cref) {
		int curRow = cref.getRow();
		int curCol = cref.getCol();
		if (grid.getCellNumber(curRow, curCol) == 0)
			grid.setCellNumber(curRow, curCol, curNum++);
		ArrayList<CellRef> possibles = countUnvisited(cref);
		int numCells = possibles.size();
		if (numCells == 0) {
			if (loopEnabled) {
				if (getRand(50) > 0)
					return;
				// make a break into another allready visited cell
				ArrayList<CellRef> poss = countVisited(cref);
				int numLoop = poss.size();
				System.out.println("numLoop = " + numLoop);
				if (numLoop < 1)
					return;
				int loopDestNum = getRand(numLoop + 1);
				CellRef loopDest = poss.get(loopDestNum % numLoop);
				grid.clearCellWall(cref.getRow(), cref.getCol(),
						loopDest.getDir());
				grid.clearCellWall(loopDest.getRow(), loopDest.getCol(),
						reverse(loopDest.getDir()));
			}
			return;
		}
		int destNum = getRand(numCells);// try numCells + 1
		if (numCells > 1)
			stack.push(cref);
		CellRef dest = possibles.get(destNum);// try destNum % numCells
		grid.clearCellWall(cref.getRow(), cref.getCol(), dest.getDir());
		grid.clearCellWall(dest.getRow(), dest.getCol(), reverse(dest.getDir()));
		checkCell(dest);
	}

	private void generateMaze() {
		stack = new Stack<CellRef>();
		grid = new CellGrid(row, col, loopEnabled);
		// set initial direction as North
		dir = 'N';
		// set start cell in row 0
		curRow = 0;
		curCol = getRand(col);
		start = new CellRef(0, curCol, 'N');
		curNum = 1;
		CellRef entry = new CellRef(curRow, curCol, dir);
		grid.clearCellWall(curRow, curCol, 'S');
		grid.setStart(new CellRef(0, curCol, 'S'));
		stack.push(entry);
		while (!stack.isEmpty()) {
			CellRef next = stack.pop();
			checkCell(next);
		}
		// make exit in last row
		curRow = row - 1;
		curCol = getRand(col);
		exit = new CellRef(curRow, curCol, 'N');
		grid.clearCellWall(curRow, curCol, 'N');
		grid.setExit(exit);
		grid.setCurrentCell(start);
	}

	private BufferedImage generateImage() {
		Dimension size = grid.getSize();
		BufferedImage image = new BufferedImage(size.width, size.height,
				BufferedImage.TYPE_INT_RGB);
		Graphics g = image.getGraphics();
		
		AWTGraphicsContext graphics = new AWTGraphicsContext(g);
		
		grid.draw2D(graphics);
		return image;
	}

	private void writeJpeg(String filename) {
		BufferedImage image = this.generateImage();
		try {
			ImageIO.write(image, "jpg", new File(filename));
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	public CellGrid generateMaze(int width, int height) {
		grid = new CellGrid(width, height, true);
		generateMaze();
		return grid;
	}

	public CellGrid generateMaze(String filename, int width, int height) {
		grid = new CellGrid(width, height, true);
		generateMaze();
		writeJpeg(filename);
		return grid;
	}

	public CellGrid generateMaze(String filename) {
		grid = new CellGrid(DEFAULT_WIDTH, DEFAULT_HEIGHT, true);
		generateMaze();
		writeJpeg(filename);
		return grid;
	}
}
